#!/usr/bin/ruby -w

require 'net/http'
require 'rexml/document'
require 'time'
require 'yaml'

begin
  config = YAML.load_file('branchhours.yml')
rescue Exception => e
  puts e
  exit
end

def prettytime (time) 
  # '9 am' and 'noon' are much more readable than '09:00 AM' and '12:00 PM'
  nice = time.strftime('%I')
  nice = nice.slice(1,2) if (nice.to_i < 10)
  nice = nice + ":" + time.strftime('%M') unless (time.strftime('%M').to_i == 0)
  nice = nice + " " + time.strftime('%p')
  nice.downcase!
  nice = "noon" if nice == '12 PM'
  return nice
end

# Get ready to give Google the start and end times for the daysInAdvance
# range of days.
# You may need to change the time zone.
startmin = Time.now.strftime("%Y-%m-%dT06:00:00-05:00")
startmax = (Time.now + config['daysInAdvance']*24*60*60).strftime("%Y-%m-%dT06:00:00-05:00")

# Hash to store opening hours, by date, then library
schedule = Hash.new do |hash, key|
  # Ruby doesn't create a hash of hashes on the fly like Perl, so
  # I'm using this from http://www.ruby-forum.com/topic/140570
  hash[key] = {}
end

STDERR.puts "Getting calendars from Google ..."
config['libraries'].each do |library|
  # The schedule hash will have YYYYMMDD dates as keys, and the
  # values will be hashes where the key is the library name and
  # the value is a human-readable string showing the opening hours
  # (or that the branch is closed).

  calendarUrl = config['googleUrl'].gsub(/::ID::/, config[library]['id'])
  calendarUrl << "&start-min=" + startmin
  calendarUrl << "&start-max=" + startmax
  STDERR.puts "  " + library
  # puts "  " + calendarUrl

  begin
    calendarXML = Net::HTTP.get_response(URI.parse(calendarUrl)).body
  rescue Exception => e
    STDERR.puts "Couldn't get #{library} calendar from Google"
    STDERR.puts "Can't connect to Google!? Aborting"
    STDERR.puts e
    exit
  end

  begin
    doc = REXML::Document.new(calendarXML)
  rescue Exception => e
    STDERR.puts "Can't parse the XML for the #{library} calendar!? Aborting"
    STDERR.puts e
    exit
  end
  doc.root.each_element('//entry') do |entry|
    # TODO Check to see if the branch is closed.
    date = Time.parse(entry.elements['gd:when'].attributes['startTime']).strftime("%Y%m%d").to_s
    open = prettytime(Time.parse(entry.elements['gd:when'].attributes['startTime']))
    close = prettytime(Time.parse(entry.elements['gd:when'].attributes['endTime']))
    hours = open + " - " + close
    hours = "closed" if entry.elements['title'].text =~ /closed/i
    # puts date + " " + hours
    schedule[date][library] = hours
  end

end

STDERR.puts "Writing calendars ..."
schedule.keys.sort {|a,b| a <=> b}.each do |day|
  # Go through each day for which we collected calendar information,
  # and dump out fragments of HTML to disk, suitable for including
  # in a web page.
  STDERR.puts day
  dayhtml = ''
  dayhtml << config['template']
  begin
    dayfile = File.new("hours-#{day}.html", "w")
    dayfile.chmod(0664)
  rescue Exception => e
    STDERR.puts "Problem creating #{day}.html. Aborting"
    STDERR.puts e
    exit
  end
  config['libraries'].each do |library|
    if schedule[day][library].nil?
      STDERR.puts "No hours information for #{library} on #{day}!"
      STDERR.puts "Please fix and rerun.  Aborting"
      exit
    end
    STDERR.puts "  " + library + ": " + schedule[day][library]
    # Build up some HTML for each library, and then replace 
    # ::LIBRARY:: in the template with that HTML.
    libraryLine = "<a href=\"#{config[library]['url']}\">#{config[library]['name']}</a>: #{schedule[day][library]}"
    dayhtml.gsub!(/::#{library.upcase}::/, libraryLine)
  end
  dayfile.write(dayhtml)
end

